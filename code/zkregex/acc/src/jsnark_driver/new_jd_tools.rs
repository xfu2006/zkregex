/** 
	Copyright Dr. CorrAuthor

	Author: Author1 , CorrAuthor
	All Rights Reserved.
	Created: 11/07/2022
	Revised: 01/12/2023 (added Author1's local parser code)
*/
/* ALL extra tools functions for jsnark_driver package */

extern crate mpi;
extern crate ark_ec;
extern crate ark_ff;
extern crate num_bigint;


use self::mpi::traits::*;
//use self::mpi::environment::*;
//use std::process::Command;
//use std::collections::HashMap;
use std::fs::File;
//use std::fs;
//use std::path::PathBuf;
//use std::str::from_utf8;
use std::io::{prelude::*, BufReader};
use profiler::config::*;
use poly::common::*;
use tools::*;
//use r1cs::dis_r1cs::*;
use r1cs::serial_r1cs::*;
use self::ark_ec::{PairingEngine};
use self::num_bigint::BigUint;
use self::ark_ff::{PrimeField};
//use std::ops::Shr;




/// All nodes send to ONE processor a u64 value
/// the main processor will return the VALID array 
/// element at 0 is for node 0 etc.
/// ALL other nodes get a Vec of 0u64.
/// size of Vec is number of processors
fn all_to_one(me: usize, main: usize, value: u64) -> Vec<u64>{
	let world = RUN_CONFIG.univ.world();
	let np = RUN_CONFIG.n_proc;
	let mut res = vec![0u64; np];
	res[me] = value;
	if me!=main{//send
		let vbytes = to_vecu8(&vec![value]);
		world.process_at_rank(main as i32).send_with_tag(&vbytes, me as i32);
	}else{
		for _i in 0..np-1{
			let r1 = world.any_process().receive_vec::<u8>();
			let v = from_vecu8::<u64>(&r1.0, 0u64)[0];
			let id = r1.1.tag() as usize;
			res[id] = v;
		}	
	}
	RUN_CONFIG.better_barrier("all_to_one");
	return res;
}


// ------------ LOCAL R1CS PARSER CODE BELOW ------------------
// Author1
// ------------------------------------------------------------

/// convert str to unsigned int
pub fn str_to_bi(num_str: &str) -> BigUint {
	let bytes = num_str.as_bytes();
	return BigUint::parse_bytes(bytes,10).unwrap();
}
/// hex string to biguint
pub fn hex_str_to_bi(num_str: &str) -> BigUint {
	let bytes = num_str.as_bytes();
	return BigUint::parse_bytes(bytes,16).unwrap();
}

/// convert from unsigned int to field element
/// Assumtpion: they are ALREADY in range!
pub fn bi_to_fr<PE:PairingEngine>(bi: &BigUint) -> PE::Fr { 
	let bytes = bi.to_bytes_le();
	let fr = PE::Fr::from_le_bytes_mod_order(&bytes);
	return fr;
}

/// convert string to field element
pub fn str_to_fr<PE:PairingEngine>(num_str: &str) -> PE::Fr {
	let bi = str_to_bi(num_str);
	return bi_to_fr::<PE>(&bi);
}

pub fn hex_str_to_fr<PE:PairingEngine>(num_str: &str) -> PE::Fr{
	let bi = hex_str_to_bi(num_str);
	return bi_to_fr::<PE>(&bi);
}

/// Given the connector file. get a list of 6 connectors
/// hashin, hashout, encryptin, encryptout, state0, state_last
/// each number represents a LOCAL var id for the node
pub fn parse_connectors(filepath: &str) 
	-> Vec<usize>{
	let file = match File::open(filepath){
		Ok(file) => file,
		Err(_) => panic!("Unable to open: {}", filepath)
	};
	let reader = BufReader::new(file);
	let mut vec = vec![];
	for (_, line) in reader.lines().enumerate(){
		let line = line.unwrap();
		let num = str_to_u64(&line.to_string()) as usize;
		vec.push(num as usize);
	}
	return vec; 
}


/// Given the R1CS file generated by JSnark 
/// generate a SERIAL R1CS instance and the Variable assignment
pub fn parse_serial_r1cs<PE:PairingEngine>(filepath: &str) 
	-> (R1CS<PE::Fr>, Vec<PE::Fr>) {
	let b_test = true;
    
	// stage 1, headers
	let mut num_io = 0usize;
	let mut num_aux = 0usize;
	let mut num_constraints = 0usize;
	let mut num_segs = 0usize;
	let mut seg_size: Vec<usize> = vec![];
	let mut num_vars;

	// stage 2, assignments
	let mut var_assigns: Vec<PE::Fr> = vec![];

	// stage 3, constraints
	let mut a : Vec<Vec<LinearTerm<PE::Fr>>> = Vec::new(); 
	let mut b : Vec<Vec<LinearTerm<PE::Fr>>> = Vec::new(); 
	let mut c : Vec<Vec<LinearTerm<PE::Fr>>> = Vec::new(); 

	// 1. read file
	let file = File::open(filepath).unwrap();
	let reader = BufReader::new(file);
	let mut stage = 1; // 1 for headers; 2 for var assigns; 3 for constraints
	
	for (_, line) in reader.lines().enumerate(){
		let line = line.unwrap();
		//println!("Line: {}",line);
		let arr = line.split(" ").collect::<Vec<&str>>();
		let word1 = arr[0];
		if stage == 1{
			if word1 == "field_order:"{ 
				//actually no need (it's parsed as 0 anyway)
				//do nothing here
			}else if word1=="primary_input_size:"{
				num_io = arr[1].parse::<usize>().unwrap(); 
			}else if word1=="aux_input_size:"{
				num_aux = arr[1].parse::<usize>().unwrap();
			}else if word1=="num_constraints:"{
				// initialize constraints
				let old_num_constraints= arr[1].parse::<usize>().unwrap();
				num_constraints = closest_pow2(old_num_constraints);
				a = vec![vec![]; num_constraints];
				b = vec![vec![]; num_constraints];
				c = vec![vec![]; num_constraints];
            }else if word1=="num_segments:"{
				num_segs = arr[1].parse::<usize>().unwrap();
			}else if word1=="seg_size:"{
				let size = arr[1].parse::<usize>().unwrap();
				seg_size.push(size);
			}else if word1=="assignments:"{
				if num_segs != seg_size.len(){
					panic!("Error: num_segments != seg_size.len()");
				}
				stage = 2;
				num_vars = num_io + num_aux;
				let mut total = 0;
				for x in &seg_size {total+=x;}
				assert!(num_aux==total, "num_aux: {} !=total: {}", num_aux, total);	
				var_assigns = vec![PE::Fr::from(0u64); num_vars + 1];
			}else{
				panic!("Unknown keyword: {}\n", word1);
			}
		}else if stage==2{
			if word1=="constraints:"{
				stage = 3;
			}else{
				let idx = arr[0].parse::<usize>().unwrap();
				let w2 = arr[1];
				let val = str_to_fr::<PE>(w2);
				var_assigns[idx] = val;
			}
		}else if stage==3{
			let cid = arr[0].parse::<usize>().unwrap(); // constraint id
			let mid = arr[1]; // matrix id
            let vid;
			if arr[2] == "-1" { 
				vid = 0
			}
			else{
				vid = arr[2].parse::<usize>().unwrap(); // variable id
			}
			let coef = str_to_fr::<PE>(arr[3]);
			let max; // current matrix (a, b, or c)
			if mid=="A"{max = &mut a;}
			else if mid=="B"{max= &mut b;}
			else if mid=="C"{max= &mut c;}
			else{panic!("ERROR unknown matrix ID: {}\n", mid);}
			let lt = LinearTerm::<PE::Fr>::new(vid,coef);
			max[cid].push(lt);
		}else{
			panic!("ERROR: shouldn't reach stage {} here in parsing.\n", stage);
		}
	
	} 
	let r1cs = R1CS::new(a, b, c, num_io+num_aux, num_constraints, num_io, num_segs, seg_size);
	if b_test {assert!(r1cs.is_satisfied(&var_assigns),"ERROR: r1cs not sat!");}
	return (r1cs, var_assigns);
}

/// Given the vars.txt generated by JSnark 
/// generate a SERIAL Variable assignment
pub fn parse_vars<PE:PairingEngine>(filepath: &str) 
	-> Vec<PE::Fr> {
	let mut num_vars;
	let mut var_assigns: Vec<PE::Fr> = vec![];

	// 1. read file
	let file = File::open(filepath).unwrap();
	let reader = BufReader::new(file);
	let mut stage = 1; // 1 for headers; 2 for var assigns
	let sample = PE::Fr::from(1u32);
	
	for (_, line) in reader.lines().enumerate(){
		let line = line.unwrap();
		//println!("Line: {}",line);
		let arr = line.split(" ").collect::<Vec<&str>>();
		let word1 = arr[0];
		if stage == 1{
			if word1 == "assignments:"{ 
				num_vars = arr[1].parse::<usize>().unwrap();
				var_assigns = vec![sample; num_vars];
				stage = 2;
			}else{
				panic!("Unknown keyword: {}\n", word1);
			}
		}else if stage==2{
				let idx = arr[0].parse::<usize>().unwrap();
				let w2 = arr[1];
				let val = str_to_fr::<PE>(w2);
				var_assigns[idx] = val;
		}else{
			panic!("ERROR: invalid stage: {}", stage);
		} //end if stage==...
	} //end for each line
	return var_assigns;
}

