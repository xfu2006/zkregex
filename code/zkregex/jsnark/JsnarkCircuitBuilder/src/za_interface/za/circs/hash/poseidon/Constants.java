/* ***************************************************
Dr. CorrAuthor
Author1
@Copyright 2021
Created: 07/1/2021
Completed: 07/13/2021
* ***************************************************/

/** **************************************************
This creates the Constants for SageGenerator.java.
Given a prime field, this will return proper constants (n, t, round_constants, MDS_matrix_field, R_F, R_P) 
to generate a hash with 256-bit strength
n = field size (253 or 251 depending on curve25519 customized for libsnark or spartan)
t = width or input length (3 or 5; we will be using 3)
R_F = full rounds
R_P = partial rounds
round_constants = randomly chosen field elements
MDS_matrix_field = matrix with elements from the prime field (this class ensures this is secure)
Given a ZaConfig object in specific constructor, returns a copy of Constants
* ***************************************************/


package za_interface.za.circs.hash.poseidon;

import java.math.BigInteger;
import java.util.HashMap;
import circuit.structure.Wire;
import za_interface.za.ZaCirc;
import za_interface.za.ZaGenerator;
import za_interface.za.Utils;
import za_interface.za.ZaConfig;
import za_interface.za.circs.hash.ZaHash2;
import za_interface.za.circs.curve.*;
import util.Util;
import examples.gadgets.math.ModConstantGadget;
import examples.gadgets.math.FieldDivisionGadget;
import java.util.*;
import java.io.*;
import java.io.Serializable;


/**
* Creates an object containing all neccessary constants for Poseidon Hash
*/
public class Constants implements Serializable{
	/**Bit Width of each hashed parameter*/
	protected int n;
	
	/**Number of inputs*/
	protected int t;

	/**
	* Number of full rounds.
	* Generated in calc_round_numbers.py
	*/
	protected int R_F;

	/**
	* Number of partial rounds.
	* Generated in calc_round_numbers.py
	*/
	protected int R_P;
	
	/**Prime number associated with prover*/
	protected BigInteger prime;
	
	/**Matrix of field elements used to randomize elements*/
	protected BigInteger[][] MDS_Matrix;

	/**Round Constants (random field elements)*/
	protected BigInteger[] round_constants;

	/** Default Constructor*/
	Constants(){
		t = R_F = R_P = 0;
		prime = null;
		MDS_Matrix = null;
		round_constants = null;
	}

	/**
	* Specific Constructor
	* @param config a ZaConfig object with prime field information
	* @return Constants object that will be used in SageGenerator.java
	*/
	public Constants(ZaConfig config){
		String name = config.field_info.name;
		//IMPROVE LATER: coz for Bls381 it's waiting 381-252 bits
		if (name == "LIBSNARK" || name == "AURORA"){
			Constants temp = findConstants("LibsnarkConstants.txt");
			// move values to this
			this.n = temp.n; 
			this.t = temp.t;
			this.prime = temp.prime;
			this.MDS_Matrix = temp.MDS_Matrix;
			this.round_constants = temp.round_constants;

			// calculated from calc_round_numbers.py
			this.R_F = 8;
			this.R_P = 114;
		}
		else if (name == "Bls381"){
			Constants temp = findConstants("Bls381Constants.txt");
			// move values to this
			this.n = temp.n; 
			this.t = temp.t;
			this.prime = temp.prime;
			this.MDS_Matrix = temp.MDS_Matrix;
			this.round_constants = temp.round_constants;

			// calculated from calc_round_numbers.py
			this.R_F = 8;
			this.R_P = 114;
		}
		else if (name == "SPARTAN"){
			Constants temp = findConstants("SpartanConstants.txt");
			// move values to this
			this.n = temp.n;
			this.t = temp.t;
			this.prime = temp.prime;
			this.MDS_Matrix = temp.MDS_Matrix;
			this.round_constants = temp.round_constants;
			
			// calculated from calc_round_numbers.py
			this.R_F = 8;
			this.R_P = 113;
			
		}else{
			throw new RuntimeException("Unsupported curve/platform: " + name);
		}
	
	}

	/**
	* Extracts constants from a text file generated by generate_parameters_grain.sage
	* @param filepath is the name of the text file in question inside poseidon_script/
	* @return Constants object with round_constants, n, t, prime, and MDS_Matrix
	*/
	protected static Constants findConstants(String filepath){
		// list of raw text by line with exactly 5 lines
		List<String> lines = readFile(filepath);
		if (lines.size()!=5){
			System.out.println("Improperly formatted file\nReturning null Constants");
			return null;
		}

		// return object
		Constants constants = new Constants();

		// All constants are in a fixed position in List<String> lines
		
		// extract round constants
		constants.round_constants = getRoundConst(lines.get(0));
		
		// extract n and t
		constants.n = Integer.parseInt(lines.get(1));
		constants.t = Integer.parseInt(lines.get(2));

		// extract prime
		// substring to eliminate "0x"
		constants.prime = new BigInteger(lines.get(3).substring(2),16); 
		// 
		constants.MDS_Matrix = getMDS(lines.get(4));

		return constants;
	}

	/**
	* Reads the file within poseidon_script and returns a list of raw text by line
	* @param filepath is the name of the file inside poseidon_script
	* @return List<String> of raw text by line
	*/
	protected static List<String> readFile(String filepath){
		//String prefix = "../../../../../../poseidon_script/"; // works from current directory
		String prefix = "poseidon_script/"; // works from JsnarkCircuitBuilder
		String data = "";
		List<String> lines = new ArrayList<String>();
		try{
			FileReader fr = new FileReader(prefix+filepath);
			BufferedReader br = new BufferedReader(fr);

			while (br.ready()){
				lines.add(br.readLine());
			}
		}
		
		catch(IOException ex){
			System.out.println("Error: File does not exist");
			ex.printStackTrace();
		}

		return lines;
	}
	
	/**
	* Separate function to extract round_constants from a given String
	* @param rounds is a line from List<String> lines associated with round_constants
	* @return BigInteger[] of extracted round_constants
	*/
	private static BigInteger[] getRoundConst(String rounds){
		rounds = rounds.substring(1,rounds.length()-1); // eliminate opening and closing brackets	
		String[] roundsArr = rounds.split(", ");
		int len = roundsArr.length;

		// convert values from Strings to BigIntegers
		BigInteger[] retRounds = new BigInteger[len];
		for (int i = 0; i < len; i++){
			String cur = trim(roundsArr[i]);
			retRounds[i] = new BigInteger(cur, 16);
		}
		return retRounds;
	}

	/**
	* Separate function to extract MDS_Matrix from a given String
	* @param rounds is a line from List<String> lines associated with MDS_Matrix
	* @return BigInteger[][] of extracted MDS_Matrix
	*/
	private static BigInteger[][] getMDS(String MDS){
		// Remove exterior brackets
		MDS = MDS.substring(1,MDS.length()-1);

		// Find Columns
		String[] mdsArr = MDS.split(",\\[");
		int rows = mdsArr.length; 
	
		// Remove end bracket from each column
		for (int i = 0; i < rows; i++){
			// remove end brackets
			mdsArr[i] = mdsArr[i].substring(0, mdsArr[i].length()-1);
		}
		
		// Find Rows
		mdsArr = Arrays.toString(mdsArr).split(", "); // split by matrix element
		int len = mdsArr.length;
		int columns = len/rows;

		// prepare to move values into return object
		BigInteger[][] retMDS = new BigInteger[rows][columns];

		// first and last strings have brackets 
		mdsArr[0] = mdsArr[0].substring(2,mdsArr[0].length());
		mdsArr[len-1] = mdsArr[len-1].substring(0,mdsArr[len-1].length()-1);
		
		// convert each string to BigInt and add to matrix
		int idx = 0;
		for (int i = 0; i<rows;i++){
			for (int j = 0; j<columns;j++){	
				String cur = trim(mdsArr[idx]);
				retMDS[i][j] = new BigInteger(cur,16);
				idx++;
			}
		}
		return retMDS;
	}

	/**
	* Trims leading hex notation and trailing apostrophe
	* @param str the hex string that is being prepared to change into a BigInteger
	* @return substring of hex String
	*/
	private static String trim(String str){
		return str.substring(3, str.length()-1);
	}
}
