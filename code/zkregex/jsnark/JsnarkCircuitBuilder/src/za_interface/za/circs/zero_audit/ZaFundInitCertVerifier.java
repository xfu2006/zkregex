/* ***************************************************
Dr. CorrAuthor
@Copyright 2021
Created: 06/08/2021
* ***************************************************/

/** **************************************************
This is a verifier for a the request for 
initializing a certificate for a fund (when it is registered).
The public input includes:
  fund_id, sid (stock id), quantity, cert_root
The private witness includes:
  fund's two secret keys, information that generates
the certificate.
The proof (generated by the verifier) certificates that
the private witness indeeds generates the information given
in the public input (claim). NOTE that the ZaSystem (server side)
has to manually verify the correct of public information.
For instance, only when YYZZ dollars are deposited, the quantity
of cash (sid: 0) is allowed to be YYZZ. The server also need
to perform DB operations such as storing the given cert_root
once it's verified. 
(See ZaSystem.handleFundInitCert(...) for details).
* ***************************************************/
package za_interface.za.circs.zero_audit;

import za_interface.za.circs.accumulator.*;
import java.math.BigInteger;
import java.util.Random;
import java.util.ArrayList;
import circuit.operations.Gadget;
import circuit.structure.Wire;
import circuit.eval.CircuitEvaluator;
import circuit.structure.WireArray;
import za_interface.za.ZaCirc;
import za_interface.za.Utils;
import za_interface.za.ZaConfig;
import za_interface.za.ZaGenerator;
import za_interface.za.circs.hash.*;
import za_interface.za.circs.accumulator.merkle.*;
import util.Util;

/** **************************************************
This is a verifier for a the request for 
initializing a certificate for a fund (when it is registered).
The public input includes:
  fund_id, sid (stock id), quantity, cert_root
The private witness includes:
  fund's two secret keys, information that generates
the certificate.
* ***************************************************/
public class ZaFundInitCertVerifier extends ZaCirc{
	// *** data members ***
	protected Cert cert;
	protected Fund fund;

	// *** Operations ***
	/** i: the i'th certificate */
	public ZaFundInitCertVerifier(ZaConfig config_in, Fund fund, int sid, ZaGenerator zg){
		super(config_in, "FundInitCertVerifier", zg);
		this.fund = fund;
		ArrayList<Cert> arrHist = fund.arrCerts.get(sid);
		this.cert = arrHist.get(arrHist.size()-1);
	}


	/** returns 5.
		fund_id, sid, quantity, ts, cert_root
	 */
	public int getNumPublicInputs(){
		return 5;
	}

	/** returns 3
		sk1, sk2, nonce (for cert) 
		where pk, quantity, ts, SID should come from the ones 
		given in public input
	*/
	public int getNumWitnessInputs(){
		return 3;
	}

	/**
		Either 1 or 0 for yes or no if the cert_root is good
	*/	
	public int getNumOutputs(){ 
		return 1;
	}

	/** 
		@arrPubInput - 
		fund_id, sid, quantity, ts, cert_root
		@arrWitness - 
		sk1, sk2, nonce (for cert) 
	*/	
	public BigInteger [] logical_eval(BigInteger [] arrPubInput, 
			BigInteger [] arrWitness){
		BigInteger fund_id = arrPubInput[0];
		BigInteger sid = arrPubInput[1];
		BigInteger q = arrPubInput[2];
		BigInteger ts = arrPubInput[3];
		BigInteger cert_root = arrPubInput[4];
		BigInteger sk1 = arrWitness[0];
		BigInteger sk2 = arrWitness[1];
		BigInteger nonce = arrWitness[2]; 
		//1. check the fund id
		ZaHash2 hash = ZaHash2.new_hash(config, (ZaGenerator) this.generator); 
		BigInteger expFundID = hash.hash2(sk1, sk2);
		boolean bRes1 = expFundID.equals(fund_id);

		//2. check the cert root
		Cert crt = new Cert(fund_id, Utils.itobi(0), 
			nonce, sid, q, ts, config);		
		boolean bRes2 = crt.root.equals(cert_root);

		BigInteger res = bRes1&&bRes2? Utils.itobi(1): Utils.itobi(0);
		return new BigInteger [] {res};
	}


	/** build the circuit. Needs to supply the input wires
		@arrPubInput - 
		fund_id, sid, quantity, ts, cert_root
		@arrWitness - 
		sk1, sk2, nonce (for cert) 
	 */
	public Wire [] build_circuit_worker(Wire [] arrPubInput, 
			Wire [] arrWitness){
		Wire fund_id = arrPubInput[0];
		Wire sid = arrPubInput[1];
		Wire q = arrPubInput[2];
		Wire ts = arrPubInput[3];
		Wire cert_root = arrPubInput[4];
		Wire sk1 = arrWitness[0];
		Wire sk2 = arrWitness[1];
		Wire nonce = arrWitness[2]; 

		//1. check the fund id
		ZaHash2 hash = ZaHash2.new_hash(config, (ZaGenerator) this.generator); 
		hash.build_circuit(new Wire [] {}, new Wire [] {sk1, sk2});
		Wire expFundID = hash.getOutputWires()[0];
		Wire bRes1 = expFundID.isEqualTo(fund_id);

		//2. check the cert root
		ZaGenerator zg = (ZaGenerator) this.generator;
		ZaCertVerifier za = new ZaCertVerifier(config, this.cert, zg);
		Wire [] arrInp = new Wire [] {};
		Wire counter = zg.createConstantWire(0);
		Wire [] arrWit = new Wire [] {fund_id, counter, nonce, sid, q, 
			ts, cert_root};
		za.build_circuit(arrInp, arrWit);
		Wire bRes2 = za.getOutputWires()[0];

		Wire res = bRes1.and(bRes2);
		return new Wire [] {res};
	}
	
	/** Generate the random inputs.  The inputs are actually NOT random,
		it is determined by the given cert in the constructor. To really
		randomize it - randomize the Fund 
	*/
	public BigInteger[][] genRandomInput(int n){
		//FIXED relative to cert
		BigInteger [][] ret = new BigInteger [][] {
			new BigInteger [] {fund.fund_id, cert.SID, cert.q, 
				cert.ts, cert.root},
			new BigInteger [] {fund.sk1, fund.sk2, cert.nonce}
		};
		//when n is odd introduce an error
		if(n%2==1){
			ret[0][4] = ret[0][4].add(Utils.itobi(3));
		}
		return ret;
	}
	
}
